<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.作为一个函数调用

        // let name = "windowsName";
        // function a() {
        //     let name = "Cherry";
        //     console.log(this.name);          // windowsName
        //     console.log("inner:" + this);    // inner: Window
        // }
        // a();
        // console.log("outer:" + this)         // outer: Window

        // 2.函数作为方法调用

        // let name = "windowsName";
        // let a = {
        //     name: "Cherry",
        //     fn: function () {
        //         console.log(this.name);      // Cherry
        //     }
        // }
        // a.fn();

        // 3.使用构造函数调用函数

        // 如果函数调用前使用了 new 关键字, 则是调用了构造函数。
        // function myFunction(arg1, arg2) {
        //     this.firstName = arg1;
        //     this.lastName = arg2;
        // }

        // let a = new myFunction("Li", "Cherry");
        // console.log(a);
        // a.lastName;

        // && new一个构造函数的过程，创建了一个新对象：
        // var a = new myFunction("Li", "Cherry");
        // new myFunction{
        //     var obj = {};
        //     obj.__proto__ = myFunction.prototype;
        //     var result = myFunction.call(obj, "Li", "Cherry");
        //     return typeof result === 'obj' ? result : obj;
        // }

        /*创建一个空对象 obj;
        将新创建的空对象的隐式原型指向其构造函数的显示原型。
        使用 call 改变 this 的指向
        如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。*/

        // 4.作为函数方法调用函数（call、apply）

        // var name = "windowsName";
        // function fn() {
        //     var name = 'Cherry';
        //     innerFunction();
        //     function innerFunction() {
        //         console.log(this.name);      // windowsName
        //     }
        // }
        // fn()
        // 这里的 innerFunction() 的调用属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，
        //所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）

        var name = "windowsName";
        var a = {
            name: "Cherry",
            func1: function () {
                console.log(this.name)
            },
            func2: function () {
                setTimeout(function () {
                    this.func1()
                }, 100);
            }
        };
        a.func2()     // this.func1 is not a function
        // 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”

        // 总结函数中的this
        /*
        1. 以函数的形式调用时，this永远都是window
        2. 以方法的形式调用时，this就是调用方法的对象
        3. 以构造函数的形式调用时，this就是新创建的对象
        4. 使用call和apply调用时，this就是指定的那个对象
        5. 在全局作用域中this代表window
        */








    </script>
</body>

</html>