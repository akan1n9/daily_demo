#### JS：

##### 改变原数组的方法：

push、pop、unshift、shift、splice、fill、reverse、sort

##### forEach：

没有返回值，只是对元素进行遍历操作。正常操作不改变原数组，涉及引用操作可改变数组

##### for in 与for of：

`for...in`循环用于遍历对象的可枚举属性。它迭代的是对象的键，而不是值。

`for...of`循环用于遍历可迭代对象（如数组、字符串、Set、Map等）。它迭代的是对象的值，而不是键。

##### splice和slice：

splice()从数组中删除指定的一个或多个元素，slice从字符串/数组中截取指定的元素

##### iterator迭代器：

JS迭代器（Iterator）是一种用于遍历数据结构的对象，它定义了一种标准的方式来访问数据结构的元素。



#### H5 and CSS：

##### 伪类和伪元素：

- 伪类用于选择元素的特定状态或行为。它们以冒号（:）开头，例如 `:hover`、`:active`、`:first-child` 等。
- 伪元素用于选择元素的特定部分，并将样式应用于该部分，在文档中插入虚构的元素。它们以双冒号（::）开头，例如 `::before`、`::after` 等。

##### css选择器优先级

内联 > ID选择器 > 类选择器 > 标签选择器

选择器优先级算法过程：

假设优先级由四个数来决定：A,B,C,D

1.如果存在内联样式，则A=1

2.B是id选择器出现的次数

3.C的值是类选择器和属性选择器和伪类出现的总次数

4.D是标签选择器和伪元素出现的次数

然后从左向右比较ABCD 位数大就优先，如果四位全部相等，则后面的覆盖前面的。

一些栗子：

```
li                                  /* (0, 0, 0, 1) */
ul li                               /* (0, 0, 0, 2) */
ul ol+li                            /* (0, 0, 0, 3) */
ul ol+li                            /* (0, 0, 0, 3) */
h1 + *[REL=up]                      /* (0, 0, 1, 1) */
ul ol li.red                        /* (0, 0, 1, 3) */
li.red.level                        /* (0, 0, 2, 1) */
a1.a2.a3.a4.a5.a6.a7.a8.a9.a10.a11  /* (0, 0, 11,0) */
#x34y                               /* (0, 1, 0, 0) */
li:first-child h2 .title            /* (0, 0, 2, 2) */
#nav .selected > a:hover            /* (0, 1, 2, 1) */
html body #nav .selected > a:hover  /* (0, 1, 2, 3) */
```

##### 移动端响应式布局

响应式布局=pc端 + 移动端

响应式布局的五种方式：

媒体查询、rem、百分比、vw vh、弹性网格布局（flex grid layout）

##### 盒模型

浏览器默认是标准盒模型：一个盒子元素的总宽度和高度包括了内容区域（content）、内边距（padding）、边框（border）和外边距（margin）。

在标准盒模型中，如果给盒子设置`width`和`height`，实际设置的是`content`内容区域的宽和高。内边距`padding`和边框`border`加上设置的宽高一起决定了盒子的大小。

通过box-sizing:border-box设置为IE盒模型（怪异盒模型）：一个盒子元素的总宽度和高度只包括了内容区域（content）和边框（border），不包括内边距（padding）和外边距（margin）。给怪异盒模型设置宽高实际是给整个盒子设置宽高，内容区域的宽高需要减去border和padding计算得出

##### filter属性

属性`filter`用于对元素的可视效果进行处理。它可以应用各种图形效果，如模糊、颜色转换、亮度调整等等

1. `blur()`：给元素应用模糊效果，值越大越模糊。
2. `brightness()`：调整元素的亮度，值为0到1之间的小数值将使元素变暗，值大于1将使元素变亮。
3. `contrast()`：调整元素的对比度，值为0到1之间的小数值将减少对比度，值大于1将增加对比度。
4. `grayscale()`：将元素转换为灰度图像，值为0到1之间的小数值将减少灰度，值为1将完全转换为灰度。
5. `hue-rotate()`：旋转元素的色相，值为角度值（0到360之间）。

#### others：

##### 浏览器缓存：

浏览器缓存是指浏览器在第一次请求资源时将资源保存到本地，以便在后续请求中直接从本地加载资源，提高网页加载速度和减轻服务器负担。浏览器缓存分为强制缓存和协商缓存两种方式。

- 强制缓存：浏览器在第一次请求资源时，服务器返回的响应头中包含了缓存策略，比如Cache-Control（设置一些缓存选项）或Expires（过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求）等。浏览器会根据这些策略判断是否将资源缓存到本地。如果资源被强制缓存，浏览器在下一次请求该资源时，会直接从本地缓存中加载，不会发送请求到服务器。
- 协商缓存：当资源没有被强制缓存时，浏览器会向服务器发送请求，服务器会判断资源是否发生了变化。如果资源没有变化，服务器会返回一个304 Not Modified的响应，告诉浏览器可以使用本地缓存。浏览器收到这个响应后，会从本地缓存加载资源。如果资源发生了变化，服务器会返回新的资源，并且在响应头中包含新的缓存策略，浏览器会根据新的策略更新本地缓存。

强制缓存和协商缓存可以一起使用，强制缓存优先级高于协商缓存。如果资源被强制缓存，浏览器不会发送请求到服务器，也不会进行协商缓存的判断。只有当资源没有被强制缓存或者强制缓存已过期时，浏览器才会发送请求到服务器进行协商缓存的判断。这样可以减少不必要的请求，提高网页加载速度。

##### cookie，localStorage、sessionStorage：

是三种用于在浏览器中存储数据的技术。

- cookie：Cookie是一小段文本信息，由服务器发送到用户的浏览器并存储在用户的计算机上。它可以在浏览器和服务器之间进行数据交换，用于跟踪用户会话、存储用户偏好设置等。Cookie具有一定的存储容量限制（通常为4KB），并且可以设置过期时间。每次用户请求同一网站时，浏览器都会将相应的Cookie发送给服务器。
- localStorage：localStorage是HTML5提供的一种在浏览器中存储数据的机制。它允许开发者存储和检索大量数据，并且数据在页面关闭后仍然存在。localStorage的存储容量通常较大（通常为5MB或更大），并且可以通过JavaScript API进行读取和写入操作。localStorage的数据存储在客户端，不会被发送到服务器。
- sessionStorage：sessionStorage也是HTML5提供的一种在浏览器中存储数据的机制，类似于localStorage。与localStorage不同的是，sessionStorage中存储的数据仅在当前会话期间有效。当用户关闭浏览器窗口或标签页时，sessionStorage中的数据将被清除。sessionStorage的使用方式与localStorage相似，通过JavaScript API进行读取和写入操作。应用：拆分多个子页面表单，例如投简历

##### Node事件循环

事件循环机制用于:管理异步API的回调函数什么时候回到主线程中执行。

Node.js采用的是异步IO模型。同步API在主线程中执行，异步API在底层的C++维护的线程中执行，异步API的回调函数也会在主线程中执行。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f9adf781ca401aacba981fd7c2bf7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="img"  />



- `Timers`：用于存储定时器的回调函数(setlnterval,setTimeout)。
- `Pending callbacks`：执行与操作系统相关的回调函数，比如启动服务器端应用时监听端口操作的回调函数就在这里调用。
- `idle，prepare`：系统内部使用。(这个我们程序员不用管)
- `Poll`：存储I/O操作的回调函数队列，比如文件读写操作的回调函数。
- `Check`：存储setlmmediate的回调函数。
- `Closingcallbacks`：执行与关闭事件相关的回调，例如关闭数据库连接的回调函数等。

记住以下几点：

1.当主线程同步代码执行完毕后才会进入事件循环

2.事件循环总共分六个阶段，并且每个阶段都包括哪些回调需要记清楚。

3.事件循环中会先执行微任务再执行宏任务。

4.微任务会穿插在这六个阶段之间执行，每进入到下个阶段前会清空当前的微任务队列。

5.微任务中process.nextTick的优先级最高，会优先执行。





